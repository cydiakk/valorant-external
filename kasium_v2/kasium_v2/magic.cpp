#include "stdafx.hpp"

#include <assert.h>

#define PAGE_SIZE 4096

namespace magic {
	//offsets for auto update
	uintptr_t magic_o_read_proxy = 0;
	uintptr_t magic_o_write_proxy = 0;
	uintptr_t magic_o_datahk = 0;
	uintptr_t magic_original_func = 0;

	byte magic[] = {
0x9C, 0x56, 0x57, 0x55, 0x50, 0x53, 0x51, 0x52, 0x54, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x4D, 0x31, 0xC9, 0x4D, 0x31, 0xD2, 0x4D, 0x31, 0xDB, 0x4D, 0x31, 0xE4, 0x4D, 0x31, 0xED, 0x4D, 0x31, 0xF6, 0x4D, 0x31, 0xFF, 0x48, 0x31, 0xF6, 0x48, 0xBB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x48, 0xB9, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x49, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0xBA, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x48, 0x89, 0xD8, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x55, 0x02, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x05, 0xDD, 0xDD, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x3F, 0x02, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x05, 0xFE, 0xCA, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x89, 0x01, 0x4C, 0x89, 0xC8, 0x48, 0x05, 0xBE, 0xBA, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x08, 0x48, 0x89, 0xD8, 0x48, 0x05, 0xEE, 0xEE, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x2B, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x40, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x1A, 0x01, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x0D, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x38, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0xFC, 0x00, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x48, 0x05, 0xF0, 0x03, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x30, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0xF4, 0x03, 0x00, 0x00, 0x89, 0x41, 0x34, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0xF8, 0x03, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x38, 0x51, 0x53, 0x48, 0x89, 0xCB, 0x4C, 0x89, 0xF9, 0x8B, 0x43, 0x48, 0x83, 0xF8, 0x00, 0x74, 0x1E, 0x8B, 0x43, 0x3C, 0x48, 0x81, 0xC1, 0xF0, 0x03, 0x00, 0x00, 0xFF, 0xD2, 0x8B, 0x43, 0x40, 0x48, 0x83, 0xC1, 0x04, 0xFF, 0xD2, 0x8B, 0x43, 0x44, 0x48, 0x83, 0xC1, 0x04, 0xFF, 0xD2, 0x5B, 0x59, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x10, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x48, 0x89, 0x41, 0x4C, 0x48, 0x05, 0xA0, 0x03, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x89, 0x41, 0x0C, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x28, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x83, 0xF8, 0x00, 0x74, 0x69, 0x49, 0x89, 0xC6, 0x48, 0x05, 0xB0, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x14, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xB4, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x18, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xB8, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x1C, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xBC, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x20, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xC0, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x24, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xC4, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x28, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xC8, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x2C, 0x48, 0x8B, 0x19, 0x49, 0x89, 0xCF, 0x4D, 0x31, 0xC9, 0x48, 0x83, 0xFB, 0x00, 0x0F, 0x84, 0xCD, 0x00, 0x00, 0x00, 0x48, 0xB9, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x4C, 0x89, 0xC2, 0x4D, 0x31, 0xC0, 0x4C, 0x6B, 0xC6, 0x08, 0x49, 0x89, 0xDA, 0x4D, 0x01, 0xC2, 0x4C, 0x89, 0xD0, 0xFF, 0xD2, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x82, 0x00, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x72, 0x73, 0x49, 0x89, 0xC3, 0x4C, 0x6B, 0xC6, 0x30, 0x49, 0x89, 0xCA, 0x4D, 0x01, 0xC2, 0x4C, 0x89, 0xD8, 0x48, 0x83, 0xC0, 0x38, 0xFF, 0xD2, 0x41, 0xBC, 0x01, 0x01, 0x1E, 0x01, 0x44, 0x39, 0xE0, 0x75, 0x52, 0x49, 0x89, 0x02, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0xD8, 0x00, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x04, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0xA0, 0x03, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x08, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0xE0, 0x03, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x10, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x10, 0x02, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x18, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x58, 0x0A, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x20, 0x4D, 0x89, 0x5A, 0x28, 0x48, 0xFF, 0xC6, 0x45, 0x8B, 0x6F, 0x08, 0x41, 0x81, 0xFD, 0x00, 0x08, 0x00, 0x00, 0x77, 0x09, 0x44, 0x39, 0xEE, 0x0F, 0x82, 0x43, 0xFF, 0xFF, 0xFF, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5C, 0x5A, 0x59, 0x5B, 0x58, 0x5D, 0x5F, 0x5E, 0x9D, 0x48, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0
	};

	uint64_t presults = 0;

	void update_shell(uintptr_t decrypted_world, uintptr_t pcodecave, uintptr_t base, uintptr_t pentitycache) {
		for (int i = 0; i <= sizeof(magic) - sizeof(UINT64); i++)
		{
			const auto pShell = (UINT64*)(magic + i);
			if (*pShell == 0xAAAAAAAAAAAAAAAA)
			{
				*pShell = decrypted_world;
			}
			if (*pShell == 0xBBBBBBBBBBBBBBBB)
			{
				*pShell = presults;
			}
			if (*pShell == 0xCCCCCCCCCCCCCCCC)
			{
				*pShell = base + magic_o_read_proxy/*MAGIC_O_READ_PROXY*/; // mov rax, [rax] => ret
			}
			if (*pShell == 0xFFFFFFFFFFFFFFFF)
			{
				*pShell = magic_original_func/*MAGIC_O_ORIGINAL*/; // World tick original
			}
			if (*pShell == 0xDDDDDDDDDDDDDDDD)
			{
				*pShell = pentitycache;
			}
			if (*pShell == 0x9999999999999999)
			{
				*pShell = base + magic_o_write_proxy/*MAGIC_O_WRITE_PROXY*/;
			}
			if (*(UINT32*)pShell == 0xDDDD)
			{
				*(UINT32*)pShell = 0x38;
			}
			if (*(UINT32*)pShell == 0xEEEE)
			{
				*(UINT32*)pShell = 0x190;
			}
			if (*(UINT32*)pShell == 0xCAFE)
			{
				*(UINT32*)pShell = 0xa0;
			}
			if (*(UINT32*)pShell == 0xBABE)
			{
				*(UINT32*)pShell = 0xa0 + sizeof(uint64_t);
			}
		}
	}

	template<class T>
	constexpr const T& clamp(const T& v, const T& lo, const T& hi)
	{
		assert(!(hi < lo));
		return (v < lo) ? lo : (hi < v) ? hi : v;
	}

	uint64_t find_hidden_module() {
		uint64_t base = core::get_process_base_by_id(globals::t_proc_id);
		DWORD valorant_pid = (DWORD)globals::t_proc_id;

		auto query = [&valorant_pid](uint64_t address, void* buffer) {
			static auto process = OpenProcess(PROCESS_QUERY_INFORMATION, false, valorant_pid);
			return VirtualQueryEx(process, reinterpret_cast<void*>(address), (PMEMORY_BASIC_INFORMATION)buffer, sizeof(MEMORY_BASIC_INFORMATION));
		};

		IMAGE_DOS_HEADER dos = core::read<IMAGE_DOS_HEADER>(globals::t_proc_id, base);
		IMAGE_NT_HEADERS nt = core::read<IMAGE_NT_HEADERS>(globals::t_proc_id, base + dos.e_lfanew);

		SYSTEM_INFO sys_info = { 0 };
		GetSystemInfo(&sys_info);
		uint64_t region_start = reinterpret_cast<uint64_t>(sys_info.lpMinimumApplicationAddress), region_end = reinterpret_cast<uint64_t>(sys_info.lpMaximumApplicationAddress);

		clock_t tick = clock();
		MEMORY_BASIC_INFORMATION mem_info = {};

		uint64_t hidden_module = NULL;

		do {
			if (query(region_start, &mem_info)) {
				if ((mem_info.State & ~MEM_FREE) && (mem_info.Type & MEM_MAPPED)) {
					uint64_t region_base = reinterpret_cast<uint64_t>(mem_info.BaseAddress); region_base -= reinterpret_cast<uint64_t>(mem_info.BaseAddress) % PAGE_SIZE;
					for (int i = 0; i < clamp(mem_info.RegionSize / PAGE_SIZE, 0ull, 1000ull); i++) {
						char output[2] = {};

						core::mem_cpy(globals::t_proc_id, region_base, GetCurrentProcessId(), (uintptr_t)output, sizeof(output));

						if (!memcmp(reinterpret_cast<void*>(output), "MZ", sizeof(output))) {
							IMAGE_DOS_HEADER dos_ = {};
							IMAGE_NT_HEADERS nt_ = {};

							dos_ = core::read<IMAGE_DOS_HEADER>(globals::t_proc_id, region_base, sizeof(dos));
							nt_ = core::read<IMAGE_NT_HEADERS>(globals::t_proc_id, region_base + dos.e_lfanew, sizeof(nt));

							bool is_exe = nt.FileHeader.Characteristics & ~(IMAGE_FILE_DLL | IMAGE_FILE_SYSTEM);
							if (dos.e_magic == IMAGE_DOS_SIGNATURE && nt.Signature == IMAGE_NT_SIGNATURE && is_exe && nt.OptionalHeader.CheckSum == nt_.OptionalHeader.CheckSum && region_base != base) {
								hidden_module = region_base;
								break;
							}
						}
						region_base += PAGE_SIZE;
					}

					if (hidden_module)
						break;
				}
			}

			region_start += mem_info.RegionSize;
		} while (region_start <= region_end);

		return hidden_module;
	}

	bool auto_update(uintptr_t& worldcrypt_key, uintptr_t& worldcrypt_state) {
		uintptr_t hidden_module = find_hidden_module();
		if (!hidden_module) { return false; }

		uint64_t base = hidden_module;
		DWORD valorant_pid = (DWORD)globals::t_proc_id;

		IMAGE_DOS_HEADER dos = core::read<IMAGE_DOS_HEADER>(globals::t_proc_id, base);
		IMAGE_NT_HEADERS nt = core::read<IMAGE_NT_HEADERS>(globals::t_proc_id, base + dos.e_lfanew);

		//really really really ghetto
		uintptr_t code_start = base + 0x1000;

		void* codebuffer = malloc((size_t)(nt.OptionalHeader.SizeOfCode));
		core::mem_cpy(globals::t_proc_id, code_start, GetCurrentProcessId(), (uintptr_t)codebuffer, nt.OptionalHeader.SizeOfCode);

		uintptr_t virtual_read_proxy = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x48\x8B\x00\xC3\x33", (char*)"xxxxx");
		if (!virtual_read_proxy) { return false; }
		magic_o_read_proxy = code_start + (virtual_read_proxy - (uintptr_t)codebuffer) - base;

		// \x48\x8D\x05\xCC\xCC\xCC\xCC\x48\x89\x01\xC3
		uintptr_t virtual_write_proxy = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x48\x89\x01\xC3", (char*)"xxxx");
		if (!virtual_write_proxy) { return false; }
		magic_o_write_proxy = code_start + (virtual_write_proxy - (uintptr_t)codebuffer) - base;

		uintptr_t virtual_hk_function = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x48\x8B\x05\xCC\xCC\xCC\xCC\x48\x03\xE9\x45\x33\xC0", (char*)"xxx????xxxxxx");
		if (!virtual_hk_function) { return false; }

		uint32_t o_datahk = core::read<uint32_t>(globals::t_proc_id, globals::t_process_base + 0x1000 + (virtual_hk_function - (uintptr_t)codebuffer) + 0x3);
		magic_o_datahk = 0x1000 + (virtual_hk_function - (uintptr_t)codebuffer) + o_datahk + 0x7;

		magic_original_func = core::read<uint64_t>(globals::t_proc_id, globals::t_process_base + magic_o_datahk);

		uintptr_t uworld_decrypt = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x44\x8B\x35\x00\x00\x00\x00\x41\x8B\xF6\x45\x8B\xCE", (char*)"xxx????xxxxxx");
		if (!uworld_decrypt) { return false; }

		uintptr_t real_decrypt = globals::t_process_base + 0x1000 + (uworld_decrypt - (uintptr_t)codebuffer);
		uint32_t data_offset = core::read<uint32_t>(globals::t_proc_id, real_decrypt + 0x3);

		worldcrypt_key = real_decrypt + data_offset + 0x7;
		worldcrypt_state = worldcrypt_key - 0x38;

		free(codebuffer);

		return true;
	}

	bool magic_scan(uintptr_t& worldcrypt_key, uintptr_t& worldcrypt_state) {
		for (int i = 0; i < 10; ++i) {
			if (!auto_update(worldcrypt_key, worldcrypt_state)) {
				Sleep(2000);
				continue;
			}

			//auto update
			if (magic_o_read_proxy && magic_o_write_proxy && magic_o_datahk && magic_original_func) {
				if (utils::is_valid_addr(worldcrypt_key) && utils::is_valid_addr(worldcrypt_state)) {
					return true;
				}
			}
			Sleep(1000);
		}
		return false;
	}

	bool write_shell(uint64_t decrypted_world, uint64_t base, uintptr_t& pentitycache, uintptr_t& plocalproxy) {
		presults = core::virtual_alloc(globals::t_proc_id, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, 0x100);
		if (!presults) { printf(_xor_("[dbg] failed to find position for results").c_str()); return false; }
		plocalproxy = presults;

		printf(_xor_("[dbg] address to write results: 0x%p\n").c_str(), presults);

		uintptr_t pcodecave = core::virtual_alloc(globals::t_proc_id, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ, sizeof(magic));
		if (!utils::is_valid_addr(pcodecave)) { printf(_xor_("[dbg] no codecave was found :-(: 0x%p\n").c_str(), pcodecave); return false; }

		uintptr_t _pentitycache = core::virtual_alloc(globals::t_proc_id, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, 0xfffff);
		if (!_pentitycache) { printf(_xor_("[dbg] failed to alloc entitycache!\n").c_str()); return false; }

		pentitycache = _pentitycache;

		printf(_xor_("[dbg] entitycache at: 0x%p\n").c_str(), _pentitycache);
		printf(_xor_("[dbg] pcodecave at: 0x%p\n").c_str(), pcodecave);

		system("pause");

		update_shell(decrypted_world, pcodecave, base, _pentitycache);

		if (!core::write_to_readonly<void>(globals::t_proc_id, (uintptr_t)magic, pcodecave, sizeof(magic))) { return false; }

		core::write<uintptr_t>(globals::t_proc_id, (uintptr_t)&pcodecave, base + magic_o_datahk, sizeof(uintptr_t));
	}

	HijackState read_results() {
		HijackState state = { 0 };
		state = core::read<HijackState>(globals::t_proc_id, presults);
		return state;
	}
}