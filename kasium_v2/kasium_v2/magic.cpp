#include "stdafx.hpp"

#include <algorithm>

#define PAGE_SIZE 4096

//1.07
//#define MAGIC_O_CODECAVE		0x137954
//#define MAGIC_O_READ_PROXY		0x29DD610
//#define MAGIC_O_WRITE_PROXY		0x120F298
//#define MAGIC_O_DATAHK			0x6BDE0C0
//#define MAGIC_O_ORIGINAL		0x283F8E0

#define MAGIC_O_CODECAVE		0x137954
#define MAGIC_O_READ_PROXY		0x29DD610
#define MAGIC_O_WRITE_PROXY		0x120F298
#define MAGIC_O_DATAHK			0x6BDE0C0
#define MAGIC_O_ORIGINAL		0x283F8E0

namespace magic {
	//offsets for auto update
	uintptr_t magic_o_read_proxy = 0;
	uintptr_t magic_o_write_proxy = 0;
	uintptr_t magic_o_datahk = 0;
	uintptr_t magic_o_original_func = 0;

	byte magic[] = { 
		0x9C, 0x56, 0x57, 0x55, 0x50, 0x53, 0x51, 0x52, 0x54, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x4D, 0x31, 0xC9, 0x4D, 0x31, 0xD2, 0x4D, 0x31, 0xDB, 0x4D, 0x31, 0xE4, 0x4D, 0x31, 0xED, 0x4D, 0x31, 0xF6, 0x4D, 0x31, 0xFF, 0x48, 0x31, 0xF6, 0x48, 0xBB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x48, 0xB9, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0x49, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0xBA, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x48, 0x89, 0xD8, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x47, 0x03, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0x34, 0x03, 0x00, 0x00, 0x48, 0x89, 0xC3, 0x48, 0x05, 0xDD, 0xDD, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x15, 0x03, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0x02, 0x03, 0x00, 0x00, 0x49, 0x89, 0xC1, 0x48, 0x05, 0xFE, 0xCA, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x89, 0x01, 0x4C, 0x89, 0xC8, 0x48, 0x05, 0xBE, 0xBA, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x08, 0x48, 0x89, 0xD8, 0x48, 0x05, 0xEE, 0xEE, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0xC5, 0x02, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0xB2, 0x02, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x40, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x98, 0x02, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0x85, 0x02, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x73, 0x01, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0x60, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x38, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x46, 0x01, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0x33, 0x01, 0x00, 0x00, 0x49, 0x89, 0xC7, 0x48, 0x05, 0x18, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x30, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x1C, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x34, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x20, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x38, 0x51, 0x53, 0x48, 0x89, 0xCB, 0x4C, 0x89, 0xF9, 0x8B, 0x43, 0x48, 0x83, 0xF8, 0x00, 0x74, 0x1E, 0x8B, 0x43, 0x3C, 0x48, 0x81, 0xC1, 0x18, 0x04, 0x00, 0x00, 0xFF, 0xD2, 0x8B, 0x43, 0x40, 0x48, 0x83, 0xC1, 0x04, 0xFF, 0xD2, 0x8B, 0x43, 0x44, 0x48, 0x83, 0xC1, 0x04, 0xFF, 0xD2, 0x5B, 0x59, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x38, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0xB7, 0x00, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x82, 0xA4, 0x00, 0x00, 0x00, 0x48, 0x89, 0x41, 0x4C, 0x48, 0x05, 0xC8, 0x03, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x48, 0x89, 0x41, 0x0C, 0x4C, 0x89, 0xF8, 0x48, 0x05, 0x50, 0x04, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x77, 0x78, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x72, 0x69, 0x49, 0x89, 0xC6, 0x48, 0x05, 0xD0, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x14, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xD4, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x18, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xD8, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x1C, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xDC, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x20, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xE0, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x24, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xE4, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x28, 0x4C, 0x89, 0xF0, 0x48, 0x05, 0xE8, 0x11, 0x00, 0x00, 0x41, 0xFF, 0xD0, 0x89, 0x41, 0x2C, 0x48, 0x8B, 0x19, 0x49, 0x89, 0xCF, 0x4D, 0x31, 0xC9, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE3, 0x0F, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE3, 0x0F, 0x82, 0xCD, 0x00, 0x00, 0x00, 0x48, 0xB9, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x4C, 0x89, 0xC2, 0x4D, 0x31, 0xC0, 0x4C, 0x6B, 0xC6, 0x08, 0x49, 0x89, 0xDA, 0x4D, 0x01, 0xC2, 0x4C, 0x89, 0xD0, 0xFF, 0xD2, 0x49, 0xBC, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x0F, 0x87, 0x82, 0x00, 0x00, 0x00, 0x49, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x39, 0xE0, 0x72, 0x73, 0x49, 0x89, 0xC3, 0x4C, 0x6B, 0xC6, 0x30, 0x49, 0x89, 0xCA, 0x4D, 0x01, 0xC2, 0x4C, 0x89, 0xD8, 0x48, 0x83, 0xC0, 0x3C, 0xFF, 0xD2, 0x41, 0xBC, 0x1E, 0x01, 0x00, 0x01, 0x44, 0x39, 0xE0, 0x75, 0x52, 0x49, 0x89, 0x02, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x04, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0xC8, 0x03, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x08, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x08, 0x04, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x10, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x38, 0x02, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x18, 0x4C, 0x89, 0xD8, 0x48, 0x05, 0x50, 0x0A, 0x00, 0x00, 0xFF, 0xD2, 0x49, 0x89, 0x42, 0x20, 0x4D, 0x89, 0x5A, 0x28, 0x48, 0xFF, 0xC6, 0x45, 0x8B, 0x6F, 0x08, 0x41, 0x81, 0xFD, 0x00, 0x08, 0x00, 0x00, 0x77, 0x09, 0x44, 0x39, 0xEE, 0x0F, 0x82, 0x43, 0xFF, 0xFF, 0xFF, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5C, 0x5A, 0x59, 0x5B, 0x58, 0x5D, 0x5F, 0x5E, 0x9D, 0x48, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0
	};

	uint64_t presults = 0;

	void update_shell(uintptr_t decrypted_world, uintptr_t pcodecave, uintptr_t base, uintptr_t pentitycache) {
		for (int i = 0; i <= sizeof(magic) - sizeof(UINT64); i++)
		{
			const auto pShell = (UINT64*)(magic + i);
			if (*pShell == 0xAAAAAAAAAAAAAAAA)
			{
				*pShell = decrypted_world;
			}
			if (*pShell == 0xBBBBBBBBBBBBBBBB)
			{
				*pShell = presults;
			}
			if (*pShell == 0xCCCCCCCCCCCCCCCC)
			{
				*pShell = base + MAGIC_O_READ_PROXY; // mov rax, [rax] => ret
			}
			if (*pShell == 0xFFFFFFFFFFFFFFFF)
			{
				*pShell = base + MAGIC_O_ORIGINAL; // World tick original
			}
			if (*pShell == 0xDDDDDDDDDDDDDDDD)
			{
				*pShell = pentitycache;
			}
			if (*pShell == 0x9999999999999999)
			{
				*pShell = base + MAGIC_O_WRITE_PROXY;
			}
			if (*(UINT32*)pShell == 0xDDDD)
			{
				*(UINT32*)pShell = 0x38;
			}
			if (*(UINT32*)pShell == 0xEEEE)
			{
				*(UINT32*)pShell = 0x190;
			}
			if (*(UINT32*)pShell == 0xCAFE)
			{
				*(UINT32*)pShell = 0xa0;
			}
			if (*(UINT32*)pShell == 0xBABE)
			{
				*(UINT32*)pShell = 0xa0 + sizeof(uint64_t);
			}
		}
	}

	uint64_t find_hidden_module() {
		uint64_t base = driver::get_process_base_by_id(globals::t_proc_id);
		printf("base: %p\n", base);

		DWORD valorant_pid = (DWORD)globals::t_proc_id;

		auto query = [&valorant_pid](uint64_t address, void* buffer) {
			static auto process = OpenProcess(PROCESS_QUERY_INFORMATION, false, valorant_pid);
			return VirtualQueryEx(process, reinterpret_cast<void*>(address), (PMEMORY_BASIC_INFORMATION)buffer, sizeof(MEMORY_BASIC_INFORMATION));
		};

		IMAGE_DOS_HEADER dos = driver::read<IMAGE_DOS_HEADER>(globals::t_proc_id, base);
		IMAGE_NT_HEADERS nt = driver::read<IMAGE_NT_HEADERS>(globals::t_proc_id, base + dos.e_lfanew);

		SYSTEM_INFO sys_info = { 0 };
		GetSystemInfo(&sys_info);
		uint64_t region_start = reinterpret_cast<uint64_t>(sys_info.lpMinimumApplicationAddress), region_end = reinterpret_cast<uint64_t>(sys_info.lpMaximumApplicationAddress);

		clock_t tick = clock();
		MEMORY_BASIC_INFORMATION mem_info = {};

		/* bruteforce dumping method */
		uint64_t hidden_module = NULL;

		do {
			if (query(region_start, &mem_info)) {
				// find hidden module
				if ((mem_info.State & ~MEM_FREE) && (mem_info.Type & MEM_MAPPED)) {
					// enumerate alignments
					uint64_t region_base = reinterpret_cast<uint64_t>(mem_info.BaseAddress); region_base -= reinterpret_cast<uint64_t>(mem_info.BaseAddress) % PAGE_SIZE;
					for (int i = 0; i < std::clamp(mem_info.RegionSize / PAGE_SIZE, 0ull, 1000ull); i++) {
						char output[2] = {};

						//protect(region_base, PAGE_EXECUTE_READWRITE, sizeof(output));
						driver::virtual_protect(globals::t_proc_id, region_base, PAGE_READWRITE, sizeof(output));
						//read(region_base, output, sizeof(output));
						driver::copy_memory(globals::t_proc_id, region_base, GetCurrentProcessId(), (uintptr_t)output, sizeof(output));

						if (!memcmp(reinterpret_cast<void*>(output), "MZ", sizeof(output))) {
							printf("found possible module: %p\n", region_base);

							IMAGE_DOS_HEADER dos_ = {};
							IMAGE_NT_HEADERS nt_ = {};
							//protect(region_base, PAGE_EXECUTE_READWRITE, sizeof(dos)); read(region_base, &dos_, sizeof(dos));
							//protect(region_base + dos.e_lfanew, PAGE_EXECUTE_READWRITE, sizeof(nt)); read(region_base + dos_.e_lfanew, &nt_, sizeof(nt));

							driver::virtual_protect(globals::t_proc_id, region_base, PAGE_READWRITE, sizeof(dos));
							dos_ = driver::read<IMAGE_DOS_HEADER>(globals::t_proc_id, region_base, sizeof(dos));
							driver::virtual_protect(globals::t_proc_id, region_base + dos.e_lfanew, PAGE_READWRITE, sizeof(nt));
							nt_ = driver::read<IMAGE_NT_HEADERS>(globals::t_proc_id, region_base + dos.e_lfanew, sizeof(nt));

							bool is_exe = nt.FileHeader.Characteristics & ~(IMAGE_FILE_DLL | IMAGE_FILE_SYSTEM);
							if (dos.e_magic == IMAGE_DOS_SIGNATURE && nt.Signature == IMAGE_NT_SIGNATURE && is_exe && nt.OptionalHeader.CheckSum == nt_.OptionalHeader.CheckSum && region_base != base) {
								printf("found hidden module; region_base: %p; size: %x; check_sum: %x\n", mem_info.BaseAddress, nt.OptionalHeader.SizeOfImage, nt.OptionalHeader.CheckSum);

								hidden_module = region_base;
								break;
							}
						}

						region_base += PAGE_SIZE;
					}

					if (hidden_module)
						break;
				}
			}

			region_start += mem_info.RegionSize;
		} while (region_start <= region_end);

		return hidden_module;
	}

	bool auto_update() {
		uintptr_t hidden_module = find_hidden_module();

		if (!hidden_module) {
			std::cout << "hidden_module_not_found" << std::endl;
			return false;
		}

		uint64_t base = hidden_module;
		DWORD valorant_pid = (DWORD)globals::t_proc_id;

		IMAGE_DOS_HEADER dos = driver::read<IMAGE_DOS_HEADER>(globals::t_proc_id, base);
		IMAGE_NT_HEADERS nt = driver::read<IMAGE_NT_HEADERS>(globals::t_proc_id, base + dos.e_lfanew);

		//really really really ghetto
		uintptr_t code_start = base + 0x1000;

		void* codebuffer = malloc((size_t)(nt.OptionalHeader.SizeOfCode));
		driver::copy_memory(globals::t_proc_id, code_start, GetCurrentProcessId(), (uintptr_t)codebuffer, nt.OptionalHeader.SizeOfCode);

		uintptr_t virtual_read_proxy = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x48\x8B\x00\xC3\x33", (char*)"xxxxx");
		if (!virtual_read_proxy) { std::cout << "failed to find read proxy" << std::endl; return false; }
		magic_o_read_proxy = code_start + (virtual_read_proxy - (uintptr_t)codebuffer);

		uintptr_t virtual_write_proxy = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x89\x01\xC3", (char*)"xxx");
		if (!virtual_write_proxy) { std::cout << "failed to find write proxy" << std::endl; return false; }
		magic_o_write_proxy = code_start + (virtual_write_proxy - (uintptr_t)codebuffer);

		uintptr_t virtual_hk_function = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x48\x8B\x05\x00\x00\x00\x00\x45\x33\xC0\x48\x8B\x4D\x08\x48\x8B\xD3\xFF\xD0\x4C", (char*)"xxx????xxxxxxxxxxxxx");
		if(!virtual_hk_function) { std::cout << "failed to find hook funciton" << std::endl; return false; }

		//calculate original function / datahk offset
		uint32_t o_datahk = driver::read<uint32_t>(globals::t_proc_id, globals::t_process_base + 0x1000 + (virtual_hk_function - (uintptr_t)codebuffer) + 0x3);
		magic_o_datahk = globals::t_process_base + 0x1000 + (virtual_hk_function - (uintptr_t)codebuffer) + o_datahk + 0x7;

		std::cout << "magic o dadta hook: " << magic_o_datahk << std::endl;

		magic_o_original_func = driver::read<uint64_t>(globals::t_proc_id, magic_o_datahk);

		std::cout << "magic o dadta hook fucntion: " << magic_o_original_func << std::endl;

		uintptr_t uworld_decrypt = utils::scanPattern((uint8_t*)codebuffer, nt.OptionalHeader.SizeOfCode, (char*)"\x44\x8B\x35\x00\x00\x00\x00\x41\x8B\xF6\x45\x8B\xCE", (char*)"xxx????xxxxxx");
		if (!uworld_decrypt) { return false; }

		uintptr_t real_decrypt = globals::t_process_base + 0x1000 + (uworld_decrypt - (uintptr_t)codebuffer);
		uint32_t data_offset = driver::read<uint32_t>(globals::t_proc_id, real_decrypt + 0x3);

		uintptr_t key = real_decrypt + data_offset + 0x7;

		std::cout << "uworld key: " << key << std::endl;

		return true;
	}

	bool write_shell(uint64_t decrypted_world, uint64_t base, uintptr_t& pentitycache, uintptr_t& plocalproxy) {
		//auto_update();

		//find a place to write the results
		presults = scan::scan_rw_memory(globals::t_proc_id, 
			(char*)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 
			(char*)"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");

		if (!presults) { printf("failed to find position for results"); return false; }
		presults += 0x16;
		plocalproxy = presults;

		printf("[dbg] address to write results: 0x%p\n", presults);

		//find codecave
		uint32_t size = 0;
		uintptr_t pdbghelp = driver::get_um_module(globals::t_proc_id, "dbghelp.dll", size);
		if (!pdbghelp) { printf(" Failed to find codecave!\n"); return false; }

		uintptr_t pcodecave = pdbghelp + MAGIC_O_CODECAVE + 0x14;
		uintptr_t validate = driver::read<uintptr_t>(globals::t_proc_id, pcodecave);
		if (validate != 0) {
			MessageBoxA(nullptr, "MAGIC ERROR :-(", "ERROR", 0);
			return false;
		}

		if (!utils::is_valid_addr(pcodecave)) { printf("[dbg] no codecave was found :-(: 0x%p\n", pcodecave); return false;  }

		uintptr_t _pentitycache = driver::virtual_alloc(globals::t_proc_id, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, 0xfffff);
		if(!_pentitycache){ printf("Failed to alloc entitycache!\n"); return false; }

		pentitycache = _pentitycache;

		printf("entitycache at: 0x%p\n", _pentitycache);
		printf("pcodecave at: 0x%p\n", pcodecave);

		update_shell(decrypted_world, pcodecave, base, _pentitycache);

		//write shellcode to readonly
		if (!driver::write_to_readonly<void>(globals::t_proc_id, (uintptr_t)magic, pcodecave, sizeof(magic))) { return false; }

		//system("pause");

		//place .data hook
		driver::write<uintptr_t>(globals::t_proc_id, (uintptr_t)&pcodecave, base + MAGIC_O_DATAHK, sizeof(uintptr_t));
	}

	HijackState read_results() {
		HijackState state = { 0 };
		state = driver::read<HijackState>(globals::t_proc_id, presults);
		return state;
	}
}